//  xstd - extension of the C++ standard library//  Copyright (C) 2013 Oleynikov Nikolay////  This program is free software: you can redistribute it and/or modify//  it under the terms of the GNU General Public License as published by//  the Free Software Foundation, either version 3 of the License, or//  (at your option) any later version.////  This program is distributed in the hope that it will be useful,//  but WITHOUT ANY WARRANTY; without even the implied warranty of//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the//  GNU General Public License for more details.////  You should have received a copy of the GNU General Public License//  along with this program.  If not, see <http://www.gnu.org/licenses/>.////  Author email: OleynikovNY@mail.runamespace xstd{    namespace chrono    {        time_t            time_point_to_time_t ( const std::chrono::time_point<std::chrono::steady_clock>& time_point )        {            /*                Expanded function code version for better understanding                auto timed_duration_since_epoch = time_point.time_since_epoch();                auto time_duration_since_epoch_in_seconds = std::chrono::duration_cast<std::chrono::seconds>(timed_duration_since_epoch);                auto seconds_count_since_epoch = time_duration_since_epoch_in_seconds.count();                return seconds_count_since_epoch;            */            return std::chrono::duration_cast<std::chrono::seconds>(time_point.time_since_epoch()).count();        }        tm                time_point_to_tm ( const std::chrono::time_point<std::chrono::steady_clock>& time_point )        {            time_t time_point_in_time_t_format = time_point_to_time_t(time_point);            tm time_point_in_tm_format = *gmtime(&time_point_in_time_t_format);            return time_point_in_tm_format;        }        std::string        time_point_to_formatted_string ( const std::chrono::time_point<std::chrono::steady_clock>& time_point , const std::string& time_format )        {            // Warning: this function is not reentrant. Thus it can not be called simultaneously in different threads.            // Warning: the size of the result string is limimed to 1024 bytes includes the terminating null-character.            // Empty format produces an empty string            if ( time_format == "" )            {                return "";            }            // Time point conversion is required            // tm time_point_in_m_format = time_point_to_tm(time_point);            time_t time_point_in_time_t_format = time_point_to_time_t(time_point);            // `char` type is guaranteed to have a size of 1 byte by standard            // const size_t char_array_max_size = static_cast<size_t>(-1);            // Allocate a buffer for a time sting on the stack with maximum available size            char time_point_array[1024];            size_t time_string_length_actual = strftime(time_point_array,1024,time_format.c_str(),gmtime(&time_point_in_time_t_format));            // If the function returns `0` it means that some error occured            if ( time_string_length_actual == 0 )            {                throw std::runtime_error("Error occured while converting a time point to a formatted string");            }            return time_point_array;        }        std::string        time_point_to_formatted_string_mt ( const std::chrono::time_point<std::chrono::steady_clock>& time_point , const std::string& time_format )        {            static std::mutex function_mutex;            std::lock_guard<std::mutex> function_lock_guard(function_mutex);            return time_point_to_formatted_string(time_point,time_format);        }    }}